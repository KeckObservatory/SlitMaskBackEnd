import re
import logger_utils as log_fun
from general_utils import do_query, commitOrRollback


########################################################################


def mark_bad_slits(db_obj, blue_id, fn2_file_path):
    msglist = []

    # strip the \n from the file - make one line for reading into a python dict
    # the new line at times comes in the middle of a string and causes issues
    with open(fn2_file_path, 'r') as f:
        cleaned_lines = []
        lines = f.readlines()
        for line in lines:
            clean_line = line.strip()
            cleaned_lines.append(clean_line)

    oneline = ''.join(cleaned_lines)

    oneline_file = f"{fn2_file_path}1"
    with open(oneline_file, 'w') as f:
        f.write(oneline)


    # check for badslits, returns {'bad_text': {}, 'bad_vert': {}, 'msg_list': []}
    parsed_f2n_info = parseF2n(oneline_file)

    # update the database to mark them as bad
    bmsglist = bSlitMarkBad(db_obj, list(parsed_f2n_info['bad_vert'].keys()))
    msglist += bmsglist

    # check the alignment boxes for problems, returns {'bad_text': {}, 'bad_geo': {}}
    bad_align_info = checkAlign(db_obj, blue_id)

    if not bad_align_info:
        return None

    for bSlitId in bad_align_info['bad_geo'].keys():
        msg = "bad alignment bSlitId %s" % (bSlitId,)
        msglist.append(msg)
        for text in bad_align_info['bad_text'][bSlitId]:
            msg = f"   {text}"
            msglist.append(msg)

    # update the database to mark them as bad
    bmsglist = bSlitMarkBad(db_obj, list(bad_align_info['bad_geo'].keys()))
    msglist += bmsglist

    return msglist


########################################################################


def parseF2n(f2npath):
    """
    acpncc is the program which reads MDF files and writes CNC mill Gcode
    acpncc produces a .f2n log file with reports about unmillable slitlets
    this function parses those .f2n log files
    this function returns selected info about unmillable slitlets

    inputs:
    f2npath      the path name of a .f2n log file

    outputs:
    badslitlist  a list of MaskBlu.bSlitId values of unmillable slitlets
    badtextdict  a dictionary of text lists about why each bSlitId was unmillable
    badvertdict  a dictionary of vertex lists for each unmillable bSlitId

    This function is the python re-creation of the original Tclx proc
    parseF2nFile
    except that the original Tclx code both parsed the .f2n log from
    acpncc and simultaneously modified the slitmask database to mark
    those unmillable MaskBlu.bSlitId records as "bad".

    This python re-creation merely returns the list of unmillable
    slitlets to the caller who can decide when it wants to modify the
    slitmask database to mark the unmillable MaskBlu.bSlitId records
    as "bad".  This avoids the Schrodinger's Cat Experiment sort
    of behavior which made the original Tclx code intractably
    intertwined and prevented compartmentalization and testing.
    """
    log = log_fun.get_log()

    bad_slit_info = {'bad_text': {}, 'bad_vert': {}, 'msg_list': []}

    # each incident may tell us about a bad slitlet
    # we want to return a list with bSlitId of each bad slitlet
    # badslitlist = []

    # Each bad slitlet has text about why it is bad.
    # We want to return a dictionary which has one key
    # for each bad slitlet, and the value of that key
    # will be a list of strings with all of the reported
    # info about that bad slitlet.
    # Only in this way can we return the text about why
    # acpncc determined that this slitlet was bad.

    try:
        fileobj = open(f2npath)
    except Exception as err:
        msg = f"Could not open {f2npath}, error {err}, type {type(err)}"
        log.error(msg)
        usrmsg = "failed to open millcode log file"
        bad_slit_info['msg_list'].append(usrmsg)
        return bad_slit_info


    f2nlist = fileobj.read()
    fileobj.close()

    # a .f2n file generated by the 2024 version of acpncc should be a python list
    # the list should be a list of acpncc "incidents" of problems with slitlets
    f2ncode = 'loclist = ' + f2nlist

    # here we are using python exec()
    globals = dict()
    locals = dict()

    # so we ASSUME that f2npath contains benign python code
    exec(f2ncode, globals, locals)
    incilist = locals['loclist']

    try:
        _ = len(incilist)
    except:
        incilist is not iterable
        msg = f'file {f2npath} does not look like a .f2n log file of acpncc incidents'
        log.error(msg)
        usrmsg = "failed to read millcode log file"
        bad_slit_info['msg_list'].append(usrmsg)
        return bad_slit_info

    # # this outputs {text "ext 2 EXTNAME ObjectCat has 93 rows which differs from DesNobj 95" }
    # # {text "ext 5 EXTNAME SlitObjMap has 93 rows which differs from DesNobj 95" }

    # an incilist should be a list of acpncc incidents
    for incidict in incilist:
        incisev = ''
        incibslitid = -1
        # we gather a list of report 'text' of the bad slitlet
        incitextlist = []
        # we gather a list of vertices of the bad slitlet
        incivertlist = []

        # each acpncc incident should be a python dict with key 'incident'
        if 'incident' in incidict:

            # each incident should have that key whose value is a unique number
            incinum = incidict['incident']
            if 'severity' in incidict:
                # severity level of this incident should be the worst
                # severity level of all the reports in this incident.
                # We use the incident severity to decide what to do
                # with all of its reports.
                incisev = incidict['severity']

            else:
                msg = 'incident %s does not have severity' % (incinum,)
                log.warning( msg )
                continue

            # Historically this program has ignored incisev other than 'error'
            # 'error' is what acpncc says for a slitlet which will not be milled
            # For slitlets which do have 'error' we want to gather the text and
            # other info about those slitlets and return all that to the caller.

            # an acpncc 'incident' dict should have one or more keys 'report<N>'
            # where <N> is enumerated starting with 1
            repnum = 1
            reportN = "report%s" % (repnum,)

            # look for key 'report<N>' in this incident
            while reportN in incidict:
                # the value of each key 'report<N>' should be a python dictionary
                repdict = incidict[reportN]

                # an acpncc report usually has a key 'text' explaining the problem
                if 'text' in repdict:
                    reptext = repdict['text']
                    if reptext in ['BluSlit']:
                        # if the 'text' value is 'BluSlit' then
                        # acpncc wrote other keys with the other
                        # info about that BluSlit
                        incibslitid = repdict['bSlitId']

                        # acpncc report about BluSlit
                        # includes Vertex<N> coordinates
                        # where N is enumerated starting with 0
                        Vertnum = 0
                        VertexN = "Vertex%s" % (Vertnum,)

                        while VertexN in repdict:
                            incivertlist.append(repdict[VertexN])
                            # get while vertexN loop ready for next vertex
                            Vertnum = Vertnum + 1
                            VertexN = "Vertex%s" % (Vertnum,)
                    else:
                        # we save text other than 'BluSlit'
                        incitextlist.append(reptext)
                else:
                    # this report had no key 'text' which we think is aberrant
                    msg = "incident %s has report %s" % (incinum,repnum)
                    log.warning(msg)
                    log.warning(incidict[reportN])

                # get while reportN loop ready for the next report
                repnum = repnum + 1
                reportN = "report%s" % (repnum,)

            # we have processed all of the content of this incident
            # so now we can stuff its info into the return structures
            if incisev in ['error',]:
                bad_slit_info['msg_list'].append(incibslitid)
                bad_slit_info['bad_text'][incibslitid] = incitextlist
                bad_slit_info['bad_vert'][incibslitid] = incivertlist

        else:
            # this python list item did not have key 'incident'
            # this probably means we just did exec() on something we will regret
            msg = "item does not have key 'incident'"
            log.error(msg)
            usrmsg = "error reading millcode log file"
            bad_slit_info['msg_list'].append(usrmsg)
            try:
                msg = 'incident %s len(incidict) = %s' % (incinum,len(incidict))
                log.error(msg)
            except:
                msg = 'incidict %s is not iterable' % (incinum,)
                log.error(msg)

    return bad_slit_info


########################################################################


def checkAlign(db, BluId):
    """
    This function queries the slitmask database looking at the
    celestial coordinates of slitlets with MaskDesign.slitType = 'A'
    which is to say, the alignment star boxes on the mask.
    Discussions with SA Greg Wirth when DEIMOS was deployed resulted
    in an agreement to perform this check to avoid asking the mill to
    attempt cutting undesirable holes in the metal of the masks.

    inputs:
        db          database object which is already connected with suitable privs
        bluid       primary key in table MaskBlu

    outputs:
        badslitlist  a list of MaskBlu.bSlitId values of "bad" alignment boxes
        badtextdict  a dictionary of text lists about why each alignbox deemed bad
        badgeomdict  a dictionary of geometry lists for each alignbox deemed bad

    This function is the python re-creation of the original Tclx proc
        checkAlign
    except that the original Tclx code both analyzed the slitlets for
    badness and simultaneously modified the slitmask database to mark
    those bad MaskBlu.bSlitId records as "bad".
    This python re-creation merely returns the list of unmillable
    slitlets to the caller who can decide when it wants to modify the
    slitmask database to mark the unmillable MaskBlu.bSlitId records
    as "bad".  This avoids the Schrodinger's Cat Experiment sort
    of behavior which made the original Tclx code intractably
    intertwined and prevented compartmentalization and testing.
    """
    log = log_fun.get_log()

    # we want to return a list with bSlitId of each bad alignment box
    # badslitlist = []

    # We provide text about why the alignment box is bad.
    # We want to return a dictionary which has one key
    # for each bad slitlet, and the value of that key
    # will be a list of strings with all of the reported
    # info about that bad alignbox.
    # In this case the lists will have only one string item,
    # but we use a list so that the return from checkAlign()
    # can be handled the same as the return from parseF2n()
    # bad_align_info = {'bad_slits': [], 'bad_text': {}, 'bad_geo': {}}
    bad_align_info = {'bad_text': {}, 'bad_geo': {}}

    curse = db.get_dict_curse()
    if not do_query('align_box_query', curse, (BluId, BluId)):
        log.error(f'Database error,  align_box_query failed {BluId}!')
        return None

    results = curse.fetchall()

    for row in results:
        bad = False

        # we gather a list of report 'text' of the bad abox
        aboxtextlist = []

        # we gather a list of geometry of the bad abox
        aboxgeomlist = []

        # set bad = True if any dim and bad
        for dim in ['slitwid', 'slitlen']:
            too = None
            if row[dim] > 5.1:
                too = 'large'
            elif row[dim] < 1.9:
                too = 'small'

            # if the slit dimension is too small or too large
            if too:
                bad = True
                aboxtextlist.append(
                    f"BluId {BluId} bSlitId {row['bslitid']} DesId "
                    f"{row['desid']} dSlitId {row['dslitid']} Alignment hole "
                    f"{dim} too {too} ({row[dim]:.02f} arcsec)"
                )
                aboxgeomlist.append(
                    f"slitWid {row['slitwid']:.02f} slitLen {row['slitlen']:.02f}"
                )
           # end if bad
        # end for dim

        angdiff = abs(row['slitlpa'] - row['slitwpa'])
        modulus = round(angdiff / 90.0)
        remaind = abs(angdiff - (modulus * 90.0))

        if remaind > 2.0:
            bad = True
            aboxtextlist.append(
                f"BluId {BluId} bSlitId {row['bslitid']} DesId {row['desid']} "
                f"dSlitId {row['desid']} Alignment hole corner not right by "
                f"{row['dslitid']:.02f} deg"
            )
            aboxgeomlist.append(
                f"slitLPA {row['slitlpa']:.02f} slitWPA {row['slitwpa']:.02f}"
            )
        # end if remaind

        if bad:
            # bad_align_info['bad_slits'].append(row['bslitid'])
            bad_align_info['bad_text'][row['bslitid']] = aboxtextlist
            bad_align_info['bad_geo'][row['bslitid']] = aboxgeomlist

        # end if bad
    # end for row

    return bad_align_info


########################################################################


def bSlitMarkBad( db, bSlitIdList ):

    """
    update the status of a blueprint

    inputs:
    db          database object which is already connected with suitable privs
    bSlitIdList a list of BluSlits.bSlitId values to be marked bad

    outputs:
    SUCCESS or FAILURE
    msglist     text explaining SUCCESS or FAILURE

    side effects:
    BluSlits.bad becomes 1 for records
    where BluSlits.bSlitId is in bSlitIdList

    This function implements part of the original Tcl code in procs
    parseF2nFile
    checkAlign
    The operational difference is that this code does not
    set all other BluSlits.bad values to 0 because the
    2024 mask transfer procedures which create the PostgreSQL
    database tables set BluSlits.bad to a default value of 0.
    The other difference is that this function is used as one of
    a chain of functions which allow finding the bad slits
    separately from modifying the database to mark them as bad.
    So the new code does not have the Schrodinger's Cat behavior
    of the original Tcl code where merely looking caused change.
    """
    log = log_fun.get_log()

    msglist = []

    if len(bSlitIdList) < 1:
        msg = "bSlitIdList is empty, no action"
        log.info(msg)
        return msglist

    bSlitBadUpdate = (
        "UPDATE BluSlits SET bad = 1"
        " WHERE bSlitId IN %s"
    )

    try:
        db.cursor.execute(bSlitBadUpdate, (tuple(bSlitIdList),) )
    except Exception as e:
        msg = f"bSlitBadUpdate failed: {db.cursor.query}: exception class " \
              f"{e.__class__.__name__}: {e}"
        log.error(msg)
        usrmsg = "update of bad slitlets failed"
        msglist.append(usrmsg)
        return msglist

    errcnt, crbmsg = commitOrRollback(db)

    if errcnt != 0:
        log.error("commitOrRollback failed")
        msglist.append(crbmsg)
        usrmsg = "bSlit mark bad did not commit"
        msglist.append(usrmsg)
        return msglist

    msg = "commitOrRollback worked, db should be changed"
    tclog.logger.info(msg)

    return msglist


########################################################################




