
def parseF2n(f2npath):
    """
    acpncc is the program which reads MDF files and writes CNC mill Gcode
    acpncc produces a .f2n log file with reports about unmillable slitlets
    this function parses those .f2n log files
    this function returns selected info about unmillable slitlets

    inputs:
    f2npath      the path name of a .f2n log file

    outputs:
    badslitlist  a list of MaskBlu.bSlitId values of unmillable slitlets
    badtextdict  a dictionary of text lists about why each bSlitId was unmillable
    badvertdict  a dictionary of vertex lists for each unmillable bSlitId

    This function is the python re-creation of the original Tclx proc
    parseF2nFile
    except that the original Tclx code both parsed the .f2n log from
    acpncc and simultaneously modified the slitmask database to mark
    those unmillable MaskBlu.bSlitId records as "bad".

    This python re-creation merely returns the list of unmillable
    slitlets to the caller who can decide when it wants to modify the
    slitmask database to mark the unmillable MaskBlu.bSlitId records
    as "bad".  This avoids the Schrodinger's Cat Experiment sort
    of behavior which made the original Tclx code intractably
    intertwined and prevented compartmentalization and testing.
    """

    # each incident may tell us about a bad slitlet
    # we want to return a list with bSlitId of each bad slitlet
    badslitlist     = []

    # Each bad slitlet has text about why it is bad.
    # We want to return a dictionary which has one key
    # for each bad slitlet, and the value of that key
    # will be a list of strings with all of the reported
    # info about that bad slitlet.
    # Only in this way can we return the text about why
    # acpncc determined that this slitlet was bad.
    badtextdict     = {}
    badvertdict     = {}

    try:
        fileobj = open(f2npath)
    except Exception as err:
        print("Could not open %s, error %s, type %s" % (f2npath,err,type(err)))
        return FAILURE,badslitlist,badtextdict,badvertdict
    # end try

    f2nlist = fileobj.read()

    fileobj.close()

    # a .f2n file generated by the 2024 version of acpncc should be a python list
    # the list should be a list of acpncc "incidents" of problems with slitlets
    f2ncode             = 'loclist = ' + f2nlist
    # here we are using python exec()
    globals             = dict()
    locals              = dict()

    # so we ASSUME that f2npath contains benign python code
    exec(f2ncode, globals, locals)
    incilist    = locals['loclist']

    try:
        numinci = len(incilist)
    except:
        # incilist is not iterable
        print('file %s does not look like a .f2n log file of acpncc incidents' % (f2npath,))
        return FAILURE,badslitlist,badtextdict,badvertdict
    # end try
    #print('file %s seems to have %s incidents' % (f2npath, numinci))

    # an incilist should be a list of acpncc incidents
    for incidict in incilist:

        incisev             = ''
        incibslitid         = -1
        # we gather a list of report 'text' of the bad slitlet
        incitextlist        = []
        # we gather a list of vertices of the bad slitlet
        incivertlist        = []

        # each acpncc incident should be a python dict with key 'incident'
        if 'incident' in incidict:

            # each incident should have that key whose value is a unique number
            incinum = incidict['incident']
            if 'severity' in incidict:
                # severity level of this incident should be the worst
                # severity level of all the reports in this incident.
                # We use the incident severity to decide what to do
                # with all of its reports.
                incisev     = incidict['severity']
                #print('incident %s has severity %s' % (incinum,incisev))

            else:
                print('incident %s does not have severity' % (incinum,))
                # this probably indicates a fatal problem
                # but we will keep looking
                continue
            # end if 'severity'

            # Historically this program has ignored incisev other than 'error'
            # 'error' is what acpncc says for a slitlet which will not be milled
            # For slitlets which do have 'error' we want to gather the text and
            # other info about those slitlets and return all that to the caller.

            # an acpncc 'incident' dict should have one or more keys 'report<N>'
            # where <N> is enumerated starting with 1
            repnum = 1
            reportN = "report%s" % (repnum,)

            # look for key 'report<N>' in this incident
            while reportN in incidict:
                # the value of each key 'report<N>' should be a python dictionary
                repdict     = incidict[reportN]

                # an acpncc report usually has a key 'text' explaining the problem
                if 'text' in repdict:
                    reptext = repdict['text']
                    if reptext in ['BluSlit']:
                        # if the 'text' value is 'BluSlit' then
                        # acpncc wrote other keys with the other
                        # info about that BluSlit
                        incibslitid = repdict['bSlitId']
                        #print("bSlitid: %s" % (incibslitid,))

                        # acpncc report about BluSlit
                        # includes Vertex<N> coordinates
                        # where N is enumerated starting with 0
                        Vertnum     = 0
                        VertexN     = "Vertex%s" % (Vertnum,)

                        while VertexN in repdict:
                            incivertlist.append(repdict[VertexN])
                            # get while vertexN loop ready for next vertex
                            Vertnum = Vertnum + 1
                            VertexN = "Vertex%s" % (Vertnum,)
                        # end while

                    else:
                        # we save text other than 'BluSlit'
                        incitextlist.append(reptext)
                    # end if
                else:
                    print("incident %s has report %s" % (incinum,repnum))
                    print('%s' % (incidict[reportN],))
                # end if text

                # get while reportN loop ready for the next report
                repnum = repnum + 1
                reportN = "report%s" % (repnum,)
            # end while reportN

            # we have processed all of the content of this incident
            # so now we can stuff its info into the return structures
            if incisev in ['error',]:
                badslitlist.append(incibslitid)
                badtextdict[incibslitid]    = incitextlist
                badvertdict[incibslitid]    = incivertlist
            # end if incisev bad enough to report slitlets

        else:

            # this python list item did not have key 'incident'
            # this probably means we just did exec() on something we will regret
            print("item does not have key 'incident'")
            try:
                print('incident %s len(incidict) = %s' % (incinum,len(incidict)))
            except:
                print('incidict %s is not iterable' % (incinum,))
            # end try
        # end if incident
    # end for incidict

    return SUCCESS,badslitlist,badtextdict,badvertdict

# end def parseF2n()

########################################################################

def checkAlign( db, BluId ):
    """
    This function queries the slitmask database looking at the
    celestial coordinates of slitlets with MaskDesign.slitType = 'A'
    which is to say, the alignment star boxes on the mask.
    Discussions with SA Greg Wirth when DEIMOS was deployed resulted
    in an agreement to perform this check to avoid asking the mill to
    attempt cutting undesirable holes in the metal of the masks.

    inputs:
    db          database object which is already connected with suitable privs
    bluid       primary key in table MaskBlu

    outputs:
    badslitlist  a list of MaskBlu.bSlitId values of "bad" alignment boxes
    badtextdict  a dictionary of text lists about why each alignbox deemed bad
    badgeomdict  a dictionary of geometry lists for each alignbox deemed bad

    This function is the python re-creation of the original Tclx proc
    checkAlign
    except that the original Tclx code both analyzed the slitlets for
    badness and simultaneously modified the slitmask database to mark
    those bad MaskBlu.bSlitId records as "bad".
    This python re-creation merely returns the list of unmillable
    slitlets to the caller who can decide when it wants to modify the
    slitmask database to mark the unmillable MaskBlu.bSlitId records
    as "bad".  This avoids the Schrodinger's Cat Experiment sort
    of behavior which made the original Tclx code intractably
    intertwined and prevented compartmentalization and testing.
    """

    # we want to return a list with bSlitId of each bad alignment box
    badslitlist     = []

    # We provide text about why the alignment box is bad.
    # We want to return a dictionary which has one key
    # for each bad slitlet, and the value of that key
    # will be a list of strings with all of the reported
    # info about that bad alignbox.
    # In this case the lists will have only one string item,
    # but we use a list so that the return from checkAlign()
    # can be handled the same as the return from parseF2n()
    badtextdict     = {}
    badgeomdict     = {}

    alignBoxQuery       = (
    "select d.DesId, d.dSlitId, d.slitWid, d.slitLen,"
    " d.slitLPA, d.slitWPA, b.bSlitId"
    " from DesiSlits d, BluSlits b"
    " where d.slitTyp = 'A'"
    " and d.DesId = (select DesId from MaskBlu where BluId = %s)"
    " and b.dSlitId = d.dSlitId"
    " and b.BluId = %s"
    )

    # during development display the query
    print(alignBoxQuery % (BluId, BluId))

    try:
        db.cursor.execute(alignBoxQuery, (BluId, BluId) )
    except Exception as e:
        msg     = ("%s failed: %s: exception class %s: %s"
        % ('alignBoxQuery', db.cursor.query, e.__class__.__name__, e) )
        tclog.logger.error( msg )
        print(msg)
        # probably want to throw some error here
        return FAILURE,badslitlist,badtextdict,badgeomdict
    # end try

    results = db.cursor.fetchall()

    for row in results:

        # we gather a list of report 'text' of the bad abox
        aboxtextlist        = []
        # we gather a list of geometry of the bad abox
        aboxgeomlist        = []

        for dim in ['slitwid','slitlen']:
            if   row[dim] > 5.1:
                bad     = True
                too     = 'large'
            elif row[dim] < 1.9:
                bad     = True
                too     = 'small'
            else:
                bad     = False
            # end if row[dim]
            if bad:
                aboxtextlist.append(
                "BluId %s bSlitId %s DesId %s dSlitId %s"
                " Alignment hole %s too %s (%.02f arcsec)"
                % (BluId, row['bslitid'], row['desid'], row['dslitid'],
                dim, too, row[dim])
                )
                aboxgeomlist.append(
                "slitWid %.02f slitLen %.02f" % (row['slitwid'], row['slitlen'])
                )
           # end if bad
        # end for dim

        angdiff = abs(row['slitlpa'] - row['slitwpa'])
        modulus = round(angdiff / 90.0)
        remaind = abs(angdiff - (modulus * 90.0))

        if remaind > 2.0:
            bad     = True
            aboxtextlist.append(
            "BluId %s bSlitId %s DesId %s dSlitId %s"
            " Alignment hole corner not right by %.02f deg"
            % (BluId, row['bslitid'], row['desid'], row['dslitid'],
            remaind)
            )
            aboxgeomlist.append(
            "slitLPA %.02f slitWPA %.02f" % (row['slitlpa'], row['slitwpa'])
            )
        # end if remaind

        if bad:
            badslitlist.append(row['bslitid'])
        # end if bad

    # end for row

    return SUCCESS,badslitlist,badtextdict,badgeomdict

# end def checkAlign()

########################################################################
